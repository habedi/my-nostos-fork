# RWeb External Push Example
# Demonstrates how external processes can push updates to connected clients
#
# Run with: ./target/release/nostos examples/rweb_external_push.nos
# Then open http://localhost:8080 in a browser
#
# The background pusher will automatically update the page every 2 seconds!

use stdlib.rweb
use stdlib.rweb.{onSessionStartCallback, onSessionEndCallback}
use stdlib.rhtml

# Shared MVar to store active writerIds
mvar activeWriters: List[Int] = []

reactive State = { counter: Int, lastPush: String }

# Background pusher - runs independently and pushes to all connected clients
backgroundPusher(n) = {
    sleep(2000)

    # Get current list of active writers
    writers = activeWriters
    println("[Pusher] Check #" ++ show(n) ++ " - found " ++ show(length(writers)) ++ " writer(s)")

    # Push update to each connected client
    writers.each(writerId => {
        msg = "Push #" ++ show(n) ++ " at " ++ show(Time.now())
        println("[Pusher] Sending to writerId=" ++ show(writerId))
        rwebPushComponent(writerId, "push-status",
            "<div style='color: lime; font-weight: bold;'>âœ“ " ++ msg ++ "</div>")
    })

    if length(writers) > 0 then
        println("[Pusher] Sent update #" ++ show(n) ++ " to " ++ show(length(writers)) ++ " client(s)")
    else ()

    backgroundPusher(n + 1)
}

session() = {
    state = State(counter: 0, lastPush: "None yet")
    (
        () => RHtml(div([
            h1("RWeb External Push Demo"),

            div([
                h3("Local State (click to increment):"),
                p("Counter: " ++ show(state.counter)),
                button("+1", dataAction: "increment")
            ], style: "margin-bottom: 20px; padding: 10px; border: 1px solid #ccc;"),

            div([
                h3("External Push Status:"),
                component("push-status", () => RHtml(
                    div("Waiting for background pusher...", style: "color: gray;")
                ))
            ], style: "padding: 10px; border: 1px solid #ccc; background: #111;"),

            p("The background process pushes updates every 2 seconds!",
              style: "margin-top: 20px; font-style: italic;")
        ])),
        (action, params) => match action {
            "increment" -> { state.counter = state.counter + 1 }
            _ -> ()
        }
    )
}

main() = {
    println("Starting RWeb External Push Demo on http://localhost:8080")
    println("Open in browser to see automatic updates from background pusher!")
    println("")

    # Set up callbacks to track writerIds for external push
    onSessionStartCallback = Some(writerId => {
        activeWriters = activeWriters ++ [writerId]
        println("[Callback] Registered writerId=" ++ show(writerId))
    })

    onSessionEndCallback = Some(writerId => {
        activeWriters = activeWriters.filter(w => w != writerId)
        println("[Callback] Unregistered writerId=" ++ show(writerId))
    })

    # Start background pusher
    spawn { backgroundPusher(1) }

    # Use standard RWeb with callbacks
    startRWeb(8080, "External Push Demo", session)
}
