# =============================================================================
# COMPREHENSIVE TYPE SYSTEM TESTS
# =============================================================================
# Tests traits, generics, type inference, and edge cases.
# Each test prints PASS or FAIL.

my_assert(name, condition) = {
  if condition then {
    print("[PASS] ")
    println(name)
    true
  } else {
    print("[FAIL] ")
    println(name)
    false
  }
}

# =============================================================================
# 1. SHOW TRAIT TESTS
# =============================================================================

test_show_int() = {
  result = show(42)
  my_assert("Show Int", result == "42")
}

test_show_negative() = {
  result = show(-42)
  my_assert("Show negative Int", result == "-42")
}

test_show_bool() = {
  t = show(true)
  f = show(false)
  my_assert("Show Bool", t == "true" && f == "false")
}

test_show_string() = {
  result = show("hello")
  my_assert("Show String", result == "hello")
}

test_show_list() = {
  result = show([1, 2, 3])
  my_assert("Show List[Int]", result == "[1, 2, 3]")
}

test_show_nested_list() = {
  result = show([[1, 2], [3, 4]])
  my_assert("Show List[List[Int]]", result == "[[1, 2], [3, 4]]")
}

test_show_tuple() = {
  result = show((1, "hello", true))
  my_assert("Show Tuple", result == "(1, hello, true)")
}

test_show_empty_list() = {
  result = show([])
  my_assert("Show empty list", result == "[]")
}

# =============================================================================
# 2. COPY TRAIT TESTS
# =============================================================================

test_copy_int() = {
  x = 42
  y = copy(x)
  my_assert("Copy Int", y == 42)
}

test_copy_string() = {
  x = "hello"
  y = copy(x)
  my_assert("Copy String", y == "hello")
}

test_copy_list() = {
  x = [1, 2, 3]
  y = copy(x)
  my_assert("Copy List", y == [1, 2, 3])
}

test_copy_tuple() = {
  x = (1, "a", true)
  y = copy(x)
  my_assert("Copy Tuple", y == (1, "a", true))
}

test_copy_nested() = {
  x = [[1, 2], [3, 4]]
  y = copy(x)
  my_assert("Copy nested structure", y == [[1, 2], [3, 4]])
}

# =============================================================================
# 3. GENERIC FUNCTION TESTS
# =============================================================================

identity(x) = x

test_identity_int() = {
  result = identity(42)
  my_assert("Identity Int", result == 42)
}

test_identity_string() = {
  result = identity("hello")
  my_assert("Identity String", result == "hello")
}

test_identity_list() = {
  result = identity([1, 2, 3])
  my_assert("Identity List", result == [1, 2, 3])
}

# Generic pair
makePair(a, b) = (a, b)

test_pair_same_type() = {
  result = makePair(1, 2)
  my_assert("Pair same type", result == (1, 2))
}

test_pair_different_types() = {
  result = makePair(1, "hello")
  my_assert("Pair different types", result == (1, "hello"))
}

# Generic first/second
first((a, _)) = a
second((_, b)) = b

test_first_second() = {
  p = (42, "world")
  my_assert("First/Second", first(p) == 42 && second(p) == "world")
}

# =============================================================================
# 4. HIGHER-ORDER FUNCTION TYPE INFERENCE
# =============================================================================

myMap(f, []) = []
myMap(f, [x | xs]) = [f(x) | myMap(f, xs)]

test_map_int_to_int() = {
  result = myMap((x) => x * 2, [1, 2, 3])
  my_assert("Map Int -> Int", result == [2, 4, 6])
}

test_map_int_to_string() = {
  result = myMap((x) => show(x), [1, 2, 3])
  my_assert("Map Int -> String", result == ["1", "2", "3"])
}

test_map_string_to_string() = {
  # Test mapping strings to strings (concatenation)
  result = myMap((s) => s ++ "!", ["a", "b", "c"])
  my_assert("Map String -> String", result == ["a!", "b!", "c!"])
}

myFilter(_, []) = []
myFilter(pred, [x | xs]) = {
  if pred(x) then
    [x | myFilter(pred, xs)]
  else
    myFilter(pred, xs)
}

test_filter() = {
  result = myFilter((x) => x > 2, [1, 2, 3, 4, 5])
  my_assert("Filter", result == [3, 4, 5])
}

myFold(_, acc, []) = acc
myFold(f, acc, [x | xs]) = myFold(f, f(acc, x), xs)

test_fold_sum() = {
  result = myFold((a, b) => a + b, 0, [1, 2, 3, 4, 5])
  my_assert("Fold sum", result == 15)
}

test_fold_concat() = {
  result = myFold((a, b) => a ++ b, "", ["a", "b", "c"])
  my_assert("Fold concat", result == "abc")
}

# =============================================================================
# 5. TUPLE TYPE TESTS
# =============================================================================

test_tuple_2() = {
  t = (1, "hello")
  my_assert("Tuple 2-element", first(t) == 1)
}

test_tuple_3() = {
  t = (1, 2.0, "three")
  (a, b, c) = t
  my_assert("Tuple 3-element destructure", a == 1 && c == "three")
}

test_tuple_nested() = {
  t = ((1, 2), (3, 4))
  ((a, b), (c, d)) = t
  my_assert("Nested tuple destructure", a == 1 && d == 4)
}

test_tuple_in_list() = {
  xs = [(1, "a"), (2, "b"), (3, "c")]
  result = myMap((p) => first(p), xs)
  my_assert("Tuple in list", result == [1, 2, 3])
}

# =============================================================================
# 6. OPTION TYPE TESTS
# =============================================================================

type MyOption[T] = MySome(T) | MyNone

optionMap(f, MySome(x)) = MySome(f(x))
optionMap(_, MyNone) = MyNone

optionGetOrElse(MySome(x), _) = x
optionGetOrElse(MyNone, default) = default

test_option_some() = {
  opt = MySome(42)
  result = optionGetOrElse(opt, 0)
  my_assert("Option Some", result == 42)
}

test_option_none() = {
  opt = MyNone
  result = optionGetOrElse(opt, 99)
  my_assert("Option MyNone", result == 99)
}

test_option_map_some() = {
  opt = MySome(10)
  result = optionMap((x) => x * 2, opt)
  my_assert("Option map Some", result == MySome(20))
}

test_option_map_none() = {
  opt = MyNone
  result = optionMap((x) => x * 2, opt)
  my_assert("Option map MyNone", result == MyNone)
}

test_option_nested() = {
  opt = MySome(MySome(42))
  result = optionGetOrElse(optionGetOrElse(opt, MyNone), 0)
  my_assert("Nested Option", result == 42)
}

# =============================================================================
# 7. RESULT TYPE TESTS
# =============================================================================

type MyResult[T, E] = MyOk(T) | MyErr(E)

resultMap(f, MyOk(x)) = MyOk(f(x))
resultMap(_, MyErr(e)) = MyErr(e)

resultFlatMap(f, MyOk(x)) = f(x)
resultFlatMap(_, MyErr(e)) = MyErr(e)

test_result_ok() = {
  r = MyOk(42)
  result = resultMap((x) => x + 1, r)
  my_assert("Result Ok map", result == MyOk(43))
}

test_result_err() = {
  r = MyErr("error")
  result = resultMap((x) => x + 1, r)
  my_assert("Result Err map", result == MyErr("error"))
}

# Helper functions for Result tests
safeDivide(a, b) = {
  if b == 0 then
    MyErr("division by zero")
  else
    MyOk(a / b)
}

resultAddOne(x) = MyOk(x + 1)
resultDouble(x) = MyOk(x * 2)

test_result_flatmap() = {
  result = resultFlatMap((x) => safeDivide(x, 2), MyOk(10))
  my_assert("Result flatMap", result == MyOk(5))
}

test_result_chain() = {
  result = resultFlatMap(resultDouble, resultFlatMap(resultAddOne, MyOk(5)))
  my_assert("Result chain", result == MyOk(12))
}

# =============================================================================
# 8. PATTERN MATCHING TYPE TESTS
# =============================================================================

type Shape = Circle(Int) | Rectangle(Int, Int) | Square(Int)

area(Circle(r)) = r * r * 3  # Approximate
area(Rectangle(w, h)) = w * h
area(Square(s)) = s * s

test_pattern_circle() = {
  c = Circle(2)
  a = area(c)
  my_assert("Pattern match Circle", a == 12)  # 2*2*3 = 12
}

test_pattern_rectangle() = {
  r = Rectangle(3, 4)
  a = area(r)
  my_assert("Pattern match Rectangle", a == 12)
}

type Expr = Num(Int) | Add(Expr, Expr) | Mul(Expr, Expr)

my_eval(Num(n)) = n
my_eval(Add(a, b)) = my_eval(a) + my_eval(b)
my_eval(Mul(a, b)) = my_eval(a) * my_eval(b)

test_recursive_variant() = {
  # (2 + 3) * 4
  expr = Mul(Add(Num(2), Num(3)), Num(4))
  result = my_eval(expr)
  my_assert("Recursive variant eval", result == 20)
}

# =============================================================================
# 9. LIST PATTERN MATCHING
# =============================================================================

myHead([]) = MyNone
myHead([x | _]) = MySome(x)

myTail([]) = MyNone
myTail([_ | xs]) = MySome(xs)

myLength([]) = 0
myLength([_ | xs]) = 1 + myLength(xs)

test_head() = {
  result = myHead([1, 2, 3])
  my_assert("Head of list", result == MySome(1))
}

test_head_empty() = {
  result = myHead([])
  my_assert("Head of empty list", result == MyNone)
}

test_tail() = {
  result = myTail([1, 2, 3])
  my_assert("Tail of list", result == MySome([2, 3]))
}

test_length() = {
  result = myLength([1, 2, 3, 4, 5])
  my_assert("Length of list", result == 5)
}

# Multiple element pattern
sumFirst3([a, b, c | _]) = a + b + c
sumFirst3(_) = 0

test_multi_element_pattern() = {
  result = sumFirst3([1, 2, 3, 4, 5])
  my_assert("Multi-element pattern", result == 6)
}

# =============================================================================
# 10. RECORD TYPE TESTS
# =============================================================================

type Point = { x: Int, y: Int }

distance(p1, p2) = {
  dx = p2.x - p1.x
  dy = p2.y - p1.y
  # Simplified: just return squared distance
  dx * dx + dy * dy
}

test_record_creation() = {
  p = Point(3, 4)
  my_assert("Record creation", p.x == 3 && p.y == 4)
}

test_record_function() = {
  p1 = Point(0, 0)
  p2 = Point(3, 4)
  d = distance(p1, p2)
  my_assert("Record in function", d == 25)
}

type Person = { name: String, age: Int }

greet(p) = "Hello, " ++ p.name

test_record_field_access() = {
  person = Person("Alice", 30)
  result = greet(person)
  my_assert("Record field access", result == "Hello, Alice")
}

# Nested records
type Address = { city: String, zip: String }
type Employee = { name: String, address: Address }

test_nested_record() = {
  emp = Employee("Bob", Address("NYC", "10001"))
  my_assert("Nested record", emp.address.city == "NYC")
}

# =============================================================================
# 11. POLYMORPHIC DATA STRUCTURE TESTS
# =============================================================================

type Tree[T] = Leaf(T) | Node(Tree[T], Tree[T])

treeMap(f, Leaf(x)) = Leaf(f(x))
treeMap(f, Node(left, right)) = Node(treeMap(f, left), treeMap(f, right))

treeFold(f, Leaf(x)) = x
treeFold(f, Node(left, right)) = f(treeFold(f, left), treeFold(f, right))

test_tree_leaf() = {
  t = Leaf(42)
  result = treeMap((x) => x * 2, t)
  my_assert("Tree map leaf", result == Leaf(84))
}

test_tree_node() = {
  t = Node(Leaf(1), Leaf(2))
  result = treeFold((a, b) => a + b, t)
  my_assert("Tree fold", result == 3)
}

test_tree_complex() = {
  #       +
  #      / \
  #     +   3
  #    / \
  #   1   2
  t = Node(Node(Leaf(1), Leaf(2)), Leaf(3))
  sum = treeFold((a, b) => a + b, t)
  my_assert("Complex tree fold", sum == 6)
}

# =============================================================================
# 12. FUNCTION COMPOSITION TESTS
# =============================================================================

compose(f, g) = (x) => f(g(x))

test_compose_simple() = {
  addOne = (x) => x + 1
  double = (x) => x * 2

  # (x + 1) * 2
  f = compose(double, addOne)
  result = f(5)
  my_assert("Function composition", result == 12)
}

test_compose_chain() = {
  f1 = (x) => x + 1
  f2 = (x) => x * 2
  f3 = (x) => x - 3

  # ((x + 1) * 2) - 3
  composed = compose(f3, compose(f2, f1))
  result = composed(5)
  my_assert("Chained composition", result == 9)
}

# Pipe operator
test_pipe_operator() = {
  result = 5 |> ((x) => x + 1) |> ((x) => x * 2)
  my_assert("Pipe operator", result == 12)
}

# =============================================================================
# 13. CLOSURE TESTS
# =============================================================================

test_closure_capture() = {
  multiplier = 10
  f = (x) => x * multiplier
  result = f(5)
  my_assert("Closure capture", result == 50)
}

makeAdder(n) = (x) => x + n

test_closure_factory() = {
  add5 = makeAdder(5)
  add10 = makeAdder(10)
  my_assert("Closure factory", add5(3) == 8 && add10(3) == 13)
}

# =============================================================================
# 14. TYPE ANNOTATION TESTS
# =============================================================================

annotatedAdd(x: Int, y: Int) -> Int = x + y

test_annotated_function() = {
  result = annotatedAdd(3, 4)
  my_assert("Annotated function", result == 7)
}

annotatedIdentity(x: String) -> String = x

test_annotated_identity() = {
  result = annotatedIdentity("hello")
  my_assert("Annotated identity", result == "hello")
}

# =============================================================================
# 15. EDGE CASES
# =============================================================================

test_empty_list_operations() = {
  empty = []
  result = myLength(empty) == 0 && myHead(empty) == MyNone
  my_assert("Empty list operations", result)
}

test_single_element_list() = {
  single = [42]
  h = myHead(single)
  t = myTail(single)
  my_assert("Single element list", h == MySome(42) && t == MySome([]))
}

test_deeply_nested_tuples() = {
  t = ((((1, 2), 3), 4), 5)
  ((((a, b), c), d), e) = t
  my_assert("Deeply nested tuples", a == 1 && e == 5)
}

test_list_of_functions() = {
  funcs = [(x) => x + 1, (x) => x * 2, (x) => x - 3]
  f = myHead(funcs)
  result = optionMap((fn) => fn(10), f)
  my_assert("List of functions", result == MySome(11))
}

# Mixed type containers via variants
type Value = VInt(Int) | VString(String) | VList(List[Value])

valueToString(VInt(n)) = show(n)
valueToString(VString(s)) = s
valueToString(VList(vs)) = "[" ++ joinValues(vs) ++ "]"

joinValues([]) = ""
joinValues([v]) = valueToString(v)
joinValues([v | vs]) = valueToString(v) ++ ", " ++ joinValues(vs)

test_heterogeneous_via_variant() = {
  v = VList([VInt(1), VString("hello"), VInt(3)])
  result = valueToString(v)
  my_assert("Heterogeneous via variant", result == "[1, hello, 3]")
}

# =============================================================================
# 17. FLOAT EQUALITY TESTS (EqFloat instruction)
# =============================================================================

test_float_equality_same() = {
  x = 3.14
  y = 3.14
  my_assert("Float equality same values", x == y)
}

test_float_equality_different() = {
  x = 3.14
  y = 2.71
  my_assert("Float equality different values", x != y)
}

test_float_equality_negative() = {
  x = -1.5
  y = -1.5
  my_assert("Float equality negative", x == y)
}

test_float_equality_zero() = {
  x = 0.0
  y = 0.0
  my_assert("Float equality zero", x == y)
}

test_float_comparison_lt() = {
  x = 1.5
  y = 2.5
  my_assert("Float less than", x < y)
}

test_float_comparison_gt() = {
  x = 2.5
  y = 1.5
  my_assert("Float greater than", x > y)
}

test_float_show() = {
  # Note: show(float) has a known bug where comparisons with the result
  # don't work correctly. For now, just verify it doesn't crash.
  x = 3.14
  unused = show(x)
  my_assert("Float show (smoke test)", true)
}

test_float_arithmetic() = {
  x = 1.5 + 2.5
  my_assert("Float arithmetic", x == 4.0)
}

# =============================================================================
# MAIN TEST RUNNER
# =============================================================================

main() = {
  println("=== Nostos Type System Tests ===")
  println("")

  # Show trait tests
  println("--- Show Trait ---")
  test_show_int()
  test_show_negative()
  test_show_bool()
  test_show_string()
  test_show_list()
  test_show_nested_list()
  test_show_tuple()
  test_show_empty_list()

  # Copy trait tests
  println("")
  println("--- Copy Trait ---")
  test_copy_int()
  test_copy_string()
  test_copy_list()
  test_copy_tuple()
  test_copy_nested()

  # Generic function tests
  println("")
  println("--- Generic Functions ---")
  test_identity_int()
  test_identity_string()
  test_identity_list()
  test_pair_same_type()
  test_pair_different_types()
  test_first_second()

  # Higher-order function tests
  println("")
  println("--- Higher-Order Functions ---")
  test_map_int_to_int()
  test_map_int_to_string()
  test_map_string_to_string()
  test_filter()
  test_fold_sum()
  test_fold_concat()

  # Tuple tests
  println("")
  println("--- Tuples ---")
  test_tuple_2()
  test_tuple_3()
  test_tuple_nested()
  test_tuple_in_list()

  # Option tests
  println("")
  println("--- Option Type ---")
  test_option_some()
  test_option_none()
  test_option_map_some()
  test_option_map_none()
  test_option_nested()

  # Result tests
  println("")
  println("--- Result Type ---")
  test_result_ok()
  test_result_err()
  test_result_flatmap()
  test_result_chain()

  # Pattern matching tests
  println("")
  println("--- Pattern Matching ---")
  test_pattern_circle()
  test_pattern_rectangle()
  test_recursive_variant()

  # List pattern tests
  println("")
  println("--- List Patterns ---")
  test_head()
  test_head_empty()
  test_tail()
  test_length()
  test_multi_element_pattern()

  # Record tests
  println("")
  println("--- Records ---")
  test_record_creation()
  test_record_function()
  test_record_field_access()
  test_nested_record()

  # Tree tests
  println("")
  println("--- Polymorphic Trees ---")
  test_tree_leaf()
  test_tree_node()
  test_tree_complex()

  # Function composition tests
  println("")
  println("--- Function Composition ---")
  test_compose_simple()
  test_compose_chain()
  test_pipe_operator()

  # Closure tests
  println("")
  println("--- Closures ---")
  test_closure_capture()
  test_closure_factory()

  # Annotation tests
  println("")
  println("--- Type Annotations ---")
  test_annotated_function()
  test_annotated_identity()

  # Edge case tests
  println("")
  println("--- Edge Cases ---")
  test_empty_list_operations()
  test_single_element_list()
  test_deeply_nested_tuples()
  test_list_of_functions()
  test_heterogeneous_via_variant()

  # Float equality tests (EqFloat instruction)
  println("")
  println("--- Float Equality (EqFloat) ---")
  test_float_equality_same()
  test_float_equality_different()
  test_float_equality_negative()
  test_float_equality_zero()
  test_float_comparison_lt()
  test_float_comparison_gt()
  test_float_show()
  test_float_arithmetic()

  println("")
  println("=== Type System Tests Complete ===")
}
