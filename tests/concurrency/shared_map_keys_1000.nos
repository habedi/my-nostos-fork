# expect: 0
# 1000 processes each increment counters atomically
# Tests that atomic self-updating pattern works correctly under high concurrency

mvar counter: Int = 0
mvar completed: Int = 0

# Atomic increment using self-updating pattern
increment_both() = {
    counter = counter + 1
    completed = completed + 1
}

spawn_workers(parent, n: Int) = if n <= 0 then () else {
    spawn { increment_both(); parent <- true }
    spawn_workers(parent, n - 1)
}

wait_all(n: Int) = if n <= 0 then () else {
    receive { _ -> wait_all(n - 1) }
}

main() = {
    me = self()

    # Verify initial state
    assert_eq(0, counter)
    assert_eq(0, completed)

    # Spawn 1000 workers
    spawn_workers(me, 1000)
    wait_all(1000)

    # Verify both counters reached 1000
    assert_eq(1000, counter)
    assert_eq(1000, completed)

    0
}
