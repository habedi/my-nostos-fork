# expect: 0
# Test master-worker pattern with shared state via MVars
# Uses mvar.update(fn) for atomic read-modify-write operations

mvar task_counter: Int = 0
mvar result_sum: Int = 0
mvar workers_done: Int = 0

# Get next task atomically using update - returns new value (1-indexed)
get_next_task_number() = task_counter.update(x => x + 1)

# Submit result atomically using update
submit_result(value) = result_sum.update(x => x + value)

# Mark worker done atomically using update
mark_done() = workers_done.update(x => x + 1)

# Worker processes exactly 'count' tasks
worker_fixed(parent, count) = {
    do_tasks(count)
    mark_done()
    parent <- "done"
}

# Process n tasks
do_tasks(n) = if n <= 0 then () else {
    task = get_next_task_number()
    result = task * task
    submit_result(result)
    do_tasks(n - 1)
}

main() = {
    me = self()

    # Spawn 4 workers, each processing exactly 10 tasks = 40 total tasks
    spawn { worker_fixed(me, 10) }
    spawn { worker_fixed(me, 10) }
    spawn { worker_fixed(me, 10) }
    spawn { worker_fixed(me, 10) }

    # Wait for all workers to finish
    receive { _ -> () }
    receive { _ -> () }
    receive { _ -> () }
    receive { _ -> () }

    # All 40 tasks should be processed
    assert_eq(40, task_counter)
    assert_eq(4, workers_done)

    # Sum of squares 1^2 + 2^2 + ... + 40^2 = 22140
    assert_eq(22140, result_sum)
    0
}
