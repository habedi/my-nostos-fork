# expect: 0
# Tests concurrent max tracking using mvar.update for atomic compare-and-swap

mvar max_val: Int = 0

# Safe pattern using update - atomically updates to max of current and n
update_max(n) = max_val.update(x => if n > x then n else x)

# Worker that submits values
worker(parent, values) = {
    values.each(v => update_max(v))
    parent <- "done"
}

main() = {
    me = self()

    # Multiple workers submitting different values
    spawn { worker(me, [50, 30, 70]) }
    spawn { worker(me, [20, 80, 40]) }
    spawn { worker(me, [90, 10, 60]) }

    # Wait for workers
    receive { _ -> () }
    receive { _ -> () }
    receive { _ -> () }

    # The maximum should be 90
    assert_eq(90, max_val)
    0
}
