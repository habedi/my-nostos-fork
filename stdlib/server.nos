# HTTP Server utilities

# --- Parameter Lookup ---

# Look up a value by key in a list of (key, value) pairs.
# Works for queryParams, cookies, formParams, headers.
# Returns "" if not found.
getParam(params, key) = match params {
    [] -> ""
    [(k, v) | rest] -> if k == key then v else getParam(rest, key)
}

# --- Response Helpers ---

# Send a plain text response (200 OK)
respondText(req, body) =
    Server.respond(req.id, 200, [("Content-Type", "text/plain")], body)

# Send a plain text response with extra headers (e.g., Set-Cookie)
respondTextWith(req, body, headers) =
    Server.respond(req.id, 200, [("Content-Type", "text/plain")] ++ headers, body)

# Send an HTML response (200 OK)
respondHtml(req, body) =
    Server.respond(req.id, 200, [("Content-Type", "text/html")], body)

# Send an HTML response with extra headers
respondHtmlWith(req, body, headers) =
    Server.respond(req.id, 200, [("Content-Type", "text/html")] ++ headers, body)

# Send a JSON response (200 OK)
respondJson(req, body) =
    Server.respond(req.id, 200, [("Content-Type", "application/json")], body)

# Send a JSON response with extra headers
respondJsonWith(req, body, headers) =
    Server.respond(req.id, 200, [("Content-Type", "application/json")] ++ headers, body)

# Send a 400 Bad Request
respond400(req, msg) =
    Server.respond(req.id, 400, [("Content-Type", "text/plain")], msg)

# Send a 401 Unauthorized
respond401(req, msg) =
    Server.respond(req.id, 401, [("Content-Type", "text/plain")], msg)

# Send a 404 Not Found
respond404(req) =
    Server.respond(req.id, 404, [("Content-Type", "text/plain")], "Not Found: " ++ req.path)

# Send a 405 Method Not Allowed
respond405(req) =
    Server.respond(req.id, 405, [("Content-Type", "text/plain")], "Method Not Allowed")

# Send a 503 Service Unavailable (e.g., pool exhausted)
respond503(req, msg) =
    Server.respond(req.id, 503, [("Content-Type", "text/plain")], msg)

# Send a redirect (302 Found)
redirect(req, url) =
    Server.respond(req.id, 302, [("Location", url)], "")

# Send a redirect with extra headers (e.g., Set-Cookie)
redirectWith(req, url, headers) =
    Server.respond(req.id, 302, [("Location", url)] ++ headers, "")

# --- Cookie Helpers ---

# Get a cookie value from cookies list
# cookies is List[(String, String)] from req.cookies
getCookie(cookies, name) = getParam(cookies, name)

# Check if a cookie exists
hasCookie(cookies, name) = getCookie(cookies, name) != ""

# Build a Set-Cookie header tuple
setCookie(name, value) =
    ("Set-Cookie", name ++ "=" ++ value ++ "; Path=/; HttpOnly")

# Build a Set-Cookie header with max age (seconds)
setCookieWithAge(name, value, maxAge) =
    ("Set-Cookie", name ++ "=" ++ value ++ "; Path=/; HttpOnly; Max-Age=" ++ show(maxAge))

# Build a secure cookie (for HTTPS)
setSecureCookie(name, value, maxAge) =
    ("Set-Cookie", name ++ "=" ++ value ++ "; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=" ++ show(maxAge))

# Build a cookie deletion header
clearCookie(name) =
    ("Set-Cookie", name ++ "=; Path=/; Max-Age=0")

# --- WebSocket Loop ---

# Run a WebSocket message loop. Handler receives (ws, msg) and returns:
#   true  -> continue receiving
#   false -> close connection
wsLoop(ws, handler) = {
    ok = try {
        msg = WebSocket.recv(ws)
        handler(ws, msg)
    } catch { _ -> {
        WebSocket.close(ws)
        false
    } }
    if ok then wsLoop(ws, handler) else ()
}

# --- Server Loop ---

# Run an HTTP server with spawn-per-request pattern.
serve(port, handler) = {
    server = Server.bind(port)
    acceptLoop(server, handler)
}

acceptLoop(server, handler) = {
    ok = try {
        req = Server.accept(server)
        spawn { handler(req) }
        true
    } catch { _ -> false }
    if ok then acceptLoop(server, handler) else ()
}

# --- Static File Serving ---

# Get MIME type from file extension
mimeType(path) = {
    ext = getExtension(path)
    match ext {
        "html" -> "text/html"
        "htm" -> "text/html"
        "css" -> "text/css"
        "js" -> "application/javascript"
        "json" -> "application/json"
        "png" -> "image/png"
        "jpg" -> "image/jpeg"
        "jpeg" -> "image/jpeg"
        "gif" -> "image/gif"
        "svg" -> "image/svg+xml"
        "ico" -> "image/x-icon"
        "woff" -> "font/woff"
        "woff2" -> "font/woff2"
        "ttf" -> "font/ttf"
        "eot" -> "application/vnd.ms-fontobject"
        "otf" -> "font/otf"
        "txt" -> "text/plain"
        "xml" -> "application/xml"
        "pdf" -> "application/pdf"
        "zip" -> "application/zip"
        "mp3" -> "audio/mpeg"
        "mp4" -> "video/mp4"
        "webp" -> "image/webp"
        "webm" -> "video/webm"
        "wasm" -> "application/wasm"
        _ -> "application/octet-stream"
    }
}

# Extract file extension from path
# Finds the last '.' and returns everything after it
getExtension(path) = {
    chars = String.chars(path)
    collectFromEnd(chars, [])
}

# Collect extension by tracking chars after the last dot
collectFromEnd(chars, afterDot) = match chars {
    [] -> String.from_chars(afterDot)
    ['.' | rest] -> collectFromEnd(rest, [])  # Reset - found a dot
    ['/' | rest] -> collectFromEnd(rest, [])  # Reset - found a slash
    [c | rest] -> collectFromEnd(rest, afterDot ++ [c])
}

# Check if MIME type is text-based (can use string body)
isTextMime(mime) = match mime {
    "text/html" -> true
    "text/css" -> true
    "text/plain" -> true
    "text/xml" -> true
    "application/javascript" -> true
    "application/json" -> true
    "application/xml" -> true
    "image/svg+xml" -> true
    _ -> false
}

# Serve a static file
# Returns true if file was served, false if not found
respondFile(req, filePath) = {
    exists = File.exists(filePath)
    if exists then {
        mime = mimeType(filePath)
        if isTextMime(mime) then {
            # Text files: read as string
            content = File.readAll(filePath)
            Server.respond(req.id, 200, [("Content-Type", mime)], content)
        } else {
            # Binary files: read as bytes (List[Int])
            bytes = File.readBytes(filePath)
            Server.respond(req.id, 200, [("Content-Type", mime)], bytes)
        }
        true
    } else false
}

# Serve static files from a directory
# Maps request path to files under the given directory
# Example: serveStatic(req, "/static", "./public")
#   /static/css/style.css -> ./public/css/style.css
serveStatic(req, urlPrefix, directory) = {
    path = req.path
    # Check if path starts with prefix
    if String.startsWith(path, urlPrefix) then {
        # Remove prefix to get relative path
        relativePath = String.substring(path, String.length(urlPrefix), String.length(path))
        # Prevent directory traversal attacks
        if String.contains(relativePath, "..") then {
            respond400(req, "Invalid path")
            true
        } else {
            filePath = directory ++ relativePath
            served = respondFile(req, filePath)
            if served then true
            else {
                respond404(req)
                true
            }
        }
    } else false
}
